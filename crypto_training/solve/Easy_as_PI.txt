This is like Rite_of_Passage, exploiting a stateless server. At this stage the server adds a hash to 
prevent tempering with the state. If the hash does not match, the player gets teleported to the NW or 
SE corner of the map. One can still remove the hash and see what is at location '5' (set state to 
5,(0,0.....0), and use the RESET command). Answering the challenge looks easy, just the first 100 
digits of pi, but actually submitting the answer requires a valid hash now, and inside the
room all hashes generated are redacted to "xxx".

The room description sends you to http://[server]/sha256_recipe, which shows the hash alg. Naively it 
looks like the state string is first getting padded to 64 bytes, then the server SECRET is appended at 
the end, then a new string is generated by inserting certain characters of the string at positions 
dictated by the digits of pi, the result of which is finally hashed using sha256. However, the pad 
does nothing when the state is longer than 64 characters, and if it is longer than 100, the SECRET 
string does not come into play at all. So a state like "0000000....05,(0,.....0)" with enough leading 
zeroes can fool the server, as long as you supply the correct hash with it (just run the hash alg on 
the string).

state=000000000000000000000000000000000000000000000000000000000000000005,(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
state_hash=8f641647801ec1294d2ff2b20b842d4bc5671493286071845628fce785632a60
ANSWER: 3141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067

If you want a one-liner:

curl "localhost:5000/api?token=secret&state=000000000000000000000000000000000000000000000000000000000000000005,(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)&state_hash=8f641647801ec1294d2ff2b20b842d4bc5671493286071845628fce785632a60&comm=ans%203141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067"



===== hash code ====

   SECRET = "..........ILLEGIBLE................."
   assert len(SECRET) == 36

   def hashState(state_str):
      padded = state_str + "p"*(64 - len(state_str)) 
      pool = padded + SECRET
      pi  = "3141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067"
      msg = ""
      for i in range(0, 100, 2):
         idx = int(pi[i:(i+2)])
         msg += pool[i] + pool[idx] + pool[i + 1]
      return hashlib.sha256(msg.encode("ascii")).hexdigest()

   def verifyHash(state_str, hash):
      return hash == hashState(state_str)


==END==
